@using Microsoft.AspNetCore.Mvc
@using Microsoft.VisualBasic
@inject FreeAITherapist AITherapist
@inject JournalService JournalService
@inject JournalStateService JournalStateService

<script defer src="/js/ChatBox.js"></script>

<div id="chatbox-button" role="button" onclick="ChatBox.openOrCloseChatbox(event)" data-target="#chatbox-body">
    <div class="button"></div>
</div>

<div id="chatbox-body" @onkeydown="Enter">
    <div id="chatbox-content" @ref="_chatboxDiv">
        <div class="ai-message">Enter any thoughts here and I will respond!</div>
    </div>
    <div id="chatbox-input-container">
        <input id="chatbox-input" type="text" @bind-value="Message" @bind-value:event="oninput">
        <div id="chatbox-send" data-target="chatbox-input" @onclick="SendMessage"></div>
    </div>
</div>

@code {
    public string Message = String.Empty;
    private int _journalId;
    private string _entrySummary = String.Empty;
    private ElementReference _chatboxDiv;
    private bool messageIsSending = false;
    protected override void OnInitialized()
    {
        JournalStateService.OnJournalChangedAsync += HandleJournalChange;
    }

    public async Task HandleJournalChange(int journalId, string journalSummary)
    {
        this._journalId = journalId;
        this._entrySummary = journalSummary;

        AITherapist.ClearContentHistory();
        AITherapist.AddOrEditJournalSummary(journalSummary);

        List<ConversationMessage>? messages = await JournalService.GetAllConversationMessage(journalId);

        if (messages != null)
        {
            foreach (var message in messages)
            {
                await AddChatBubble(message.Content, message.Role == ChatProfile.User);
                AITherapist.AddToContentHistory(message.Content, message.Role == ChatProfile.User ? GeminiAPIRole.user :
                GeminiAPIRole.model);
            }
        }

    }

    protected async Task SendMessage()
    {
        if (string.IsNullOrEmpty(Message) || this._journalId == 0) return;

        // if message is already sending, return to avoid duplicate sends
        if (messageIsSending) return;

        string messageCopy = Message;
        messageIsSending = true;

        // reset message
        this.Message = "";
        try
        {
            // save user message to db and add change to UI
            await JournalService.AddConversationMessage(this._journalId, messageCopy, ChatProfile.User);
            await AddChatBubble(messageCopy, isUser: true);


            string response = await AITherapist.Converse(messageCopy);

            await JournalService.AddConversationMessage(this._journalId, response, ChatProfile.AI);
            await AddChatBubble(response, isUser: false);

        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: Something went wrong. Please try again. Error: ", ex.Message);
            await AddChatBubble("I'm having trouble responding. Try again later.", isUser: false);
        }

        messageIsSending = false;
    }

    protected async Task Enter(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            await SendMessage();
        }
    }

    protected async Task AddChatBubble(string chatMessage, bool isUser)
    {
        await JS.InvokeVoidAsync("ChatBox.addMessage", _chatboxDiv, chatMessage, isUser);
    }

    public void Dispose()
    {
        JournalStateService.OnJournalChangedAsync -= HandleJournalChange;
    }

    [Inject] private IJSRuntime JS { get; set; } = default!;
}